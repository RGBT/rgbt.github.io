<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue.js动态组件打造Tab选项卡]]></title>
    <url>%2Ftab%2F</url>
    <content type="text"><![CDATA[Vue.js中除了数据驱动操作DOM之外，还有一个同样重要的概念：组件。当下的前端开发愈发趋向模块化、组件化，为了冗余代码的减少，重用性、复用性的提高，进而来提高开发效率，所以需要将HTML、CSS、JS等进行封装，形成独立的组件或模块，功能上也大大加强。 当然，想要使用组件，必须要先进行注册，类似于JavaScript中想要使用某一个变量，就必须事先声明。组件名称一般是自定义，建议使用-来连接，以示区别。 说到组件，就不得不说组件之间的通信，包括父组件与子组件的通信、子组件与父组件的通信、兄弟组件的通信。 父组件与子组件的通信？ 父组件与子组件的通信，需要使用属性来进行传递。在父组件中，通过v-bind绑定自定义属性，而在子组件中，需要接收父组件传递过来的属性，这时就需要用到props。 子组件与父组件的通信？ 子组件与父组件的通信中，需要用到$on来监听事件，$emit来发射或触发事件，用$broadcast来广播事件。 兄弟组件的通信？ 一般而言，兄弟组件通信比较繁琐，需要用到一个专门的状态管理模式-vuex。 温馨提示：因为此文并不涉及到兄弟组件通信，所以之后会单独成文介绍vuex。 Tab选项卡代码如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;meta charset="utf-8"&gt;&lt;head&gt; &lt;title&gt;Tab选项卡&lt;/title&gt; &lt;script src="https://cdn.bootcss.com/vue/2.5.15/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='app'&gt; &lt;button type='button' @click="first='my-current'"&gt;第1项&lt;/button&gt; &lt;button type='button' @click="first='my-second'"&gt;第2项&lt;/button&gt; &lt;button type='button' @click="first='my-third'"&gt;第3项&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;component :is='first'&gt;&lt;/component&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:'#app', data:&#123; first: 'my-current' &#125;, components:&#123; 'my-current':&#123; template:'&lt;div&gt;&lt;p&gt;我是Tab选项卡的第1项&lt;/p&gt;&lt;/div&gt;', &#125;, 'my-second':&#123; template:'&lt;div&gt;&lt;p&gt;我是Tab选项卡的第2项&lt;/p&gt;&lt;/div&gt;' &#125;, 'my-third':&#123; template:'&lt;div&gt;&lt;p&gt;我是Tab选项卡的第3项&lt;/p&gt;&lt;/div&gt;' &#125;, &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上述代码中，Vue实例data中第一个选项卡的名字是my-current，三个组件分别是my-current、my-second、my-third。而在视图中，利用按钮绑定点击事件，is属性来挂在组件。 温馨提示：组件之间通信一般需要配合template模板来使用，并且template模板中需要有根标签来包裹内容；如果没有，则视图中无法渲染，是空白状态。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ajax跨域请求豆瓣电影Top250]]></title>
    <url>%2Fajax%2F</url>
    <content type="text"><![CDATA[今天在学习Ajax请求豆瓣电影Top250接口过程中出现了一些问题，经过搜索资料查询，是Ajax在请求过程中出现的跨域问题，特此形成文字记录自己学习技术中遇到的问题，提高自己解决问题能力的同时，也希望能够帮到正在学习Ajax道路上的小伙伴。 豆瓣电影Top250API接口: https://api.douban.com/v2/movie/top250 什么是Ajax？ AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 Ajax的工作原理？ Ajax工作原理是一个页面的指定位置可以加载另一个页面所有的输出内容，这样就实现了一个静态页面也能获取到数据库中的返回数据信息了，借此实现了一个静态网页在不刷新整个页面的情况下能做到与服务器通信，减少了用户等待时间，同时降低了网络流量，增强了用户产品体验度。 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;meta charset="utf-8"&gt;&lt;head&gt; &lt;title&gt;豆瓣电影top250&lt;/title&gt; &lt;style&gt; .user&#123; display: inline-block; text-align: center; &#125; &lt;/style&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="title"&gt;&lt;/div&gt; &lt;button id="btn"&gt;ajax请求&lt;/button&gt; &lt;script&gt; $('#btn').on('click',function()&#123; $.ajax(&#123; url:'https://api.douban.com/v2/movie/top250', type:'GET', success:function(data)&#123; console.log(data); &#125; &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 测试结果如下图： 什么是Ajax跨域？ 跨域，是指因浏览器施加了安全限制，测试时不能执行某些脚本，是由浏览器的同源策略造成的。 温馨提示：同源是指域名、协议、端口都相同。 跨域问题如何解决？ 第一种：使用JSONP。(注意JSONP只支持GET请求方式，并不支持POST请求方式)。 第二种：使用XHR2(XMLHttpRequest Level2)，是H5提供的方法，IE10以上版本都支持。服务端可添加以下代码：header(‘Access-Control-Allow-Origin:*’); //允许所有来源访问 header(‘Access-Control-Allow-Method:POST,GET’); //允许访问的方式 第三种：使用代理。(暂不详细介绍，想知道的小伙伴可自行百度搜索查询) 在这里，我使用的是JSONP的方式解决问题的，可看如下代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;meta charset="utf-8"&gt;&lt;head&gt; &lt;title&gt;豆瓣电影top250&lt;/title&gt; &lt;style&gt; .user&#123; display: inline-block; text-align: center; &#125; &lt;/style&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="title"&gt;&lt;/div&gt; &lt;button id="btn"&gt;ajax请求&lt;/button&gt; &lt;script&gt; $('#btn').on('click',function()&#123; $.ajax(&#123; url:'https://api.douban.com/v2/movie/top250', type:'GET', dataType: 'jsonp', //解决跨域问题 success:function(data)&#123; var output = ''; for(let i in data.subjects)&#123; output += ` &lt;div class="user"&gt; &lt;img src="$&#123;data.subjects[i].images.small&#125;" width="150" height="150"/&gt;&lt;br&gt; $&#123;data.subjects[i].title&#125;&lt;br&gt; $&#123;data.subjects[i].rating.average&#125; &lt;/div&gt; `; &#125; document.getElementById('title').innerHTML = output; &#125; &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 以上代码请求的是豆瓣电影Top250API接口的电影海报、评分和电影名字。 同时测试结果如下图：]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo博客如何绑定个人独立域名]]></title>
    <url>%2Fyuming%2F</url>
    <content type="text"><![CDATA[之前分享的文章中提到，我使用Node.js配合GitHub搭建的个人博客，地址为http://rgbt.github.io ，不过这是github为个人分配的二级域名，因为之前在阿里云购买了域名(域名购买后，是需要实名认证的，之后耐心等待审核通过。)，经过折腾配置，终于成功了！！！故成文后分享遨游在代码世界里的你，希望可以帮到异常努力的你:) 实操步骤？ 首先打开阿里云控制台，选择左侧的域名，之后点击解析，如下图： 接着来到DNS解析页面，点击右侧的添加解析，依次添加如下图红框中的内容。 第一个是：记录类型是CNAME，主机记录是www，记录值rgb.github.io(实际以你的为准)，确认即可。 第二个是：记录类型是A，主机记录是@，记录值是192.30.252.154。 第三个是：记录类型是A，主机记录是@，记录值是192.30.252.153。 特别提示？192.30.252.154与192.30.252.153是github官方提供的IP地址。 以上设置完成后，还不能马上通过域名访问博客，还有最后一步：你需要在你的hexo根目录下添加一个CNAME文件(该文件没有任何后缀)，内容添加上域名信息，如guobingtao.com。最后使用hexo clean命令清理hexo，再次使用hexo deploy命令重新发布即可。]]></content>
  </entry>
  <entry>
    <title><![CDATA[两个按钮引发的代码延伸思考]]></title>
    <url>%2FaddCart%2F</url>
    <content type="text"><![CDATA[经常网购剁手的小伙伴对于购物车中有两个按钮应该不会陌生，就是通过加号和减号来增减所买宝贝产品的数量。哈哈……今天这篇文章是我在学习vue.js的组件过程中联想到的一些，主要探讨的是这两个按钮的不同的实现方法，快来吧，要开讲啦！ 利用JavaScript点击事件简单实现 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;meta charset="utf-8"&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="btn1"&gt;+&lt;/button&gt; &lt;input type="text" value="1" id="count"&gt; &lt;button id="btn2"&gt;-&lt;/button&gt; &lt;script&gt; window.onload = function()&#123; var Btn1 = document.getElementById('btn1'); var Btn2 = document.getElementById('btn2'); var Count = document.getElementById('count'); Btn1.onclick = function () &#123; Count.value++; &#125; Btn2.onclick = function () &#123; Count.value--; if(Count.value &lt;= 0)&#123; Count.value = 1; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上述代码通过JS实现增减按钮相对有一定前端基础的小伙伴较为容易一些，这里不做解释。 运用Vue.js中的简单指令实现 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;meta charset="utf-8"&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="https://cdn.bootcss.com/vue/2.5.13/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;button @click = "Reduce" :disabled="count === 1"&gt;-&lt;/button&gt; &#123;&#123; count &#125;&#125; &lt;button @click = "Add"&gt;+&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; count: 0 &#125;, methods: &#123; Add: function()&#123; this.count++; &#125;, Reduce: function()&#123; this.count--; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上述代码中，@click是vue2.0版本中的写法，相当于vue1.0中的v-on:click。通过el挂载元素，v-on指令绑定事件，methods中两个时间都是函数，算是vue.js的中规中矩的写法。不过值得一提的是当数量减小到1的时候就不能再点击了，上述代码中直接在第二个按钮中使用了:disabled=”count === 1”，做了很好的处理。当然，小伙伴们也可以在methods的Reduce函数中先进行判断，当数量count为1的时候，做相应的处理。 运用Vue.js中的组件实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;meta charset="utf-8"&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="https://cdn.bootcss.com/vue/2.5.13/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt; &lt;my-component @add="handleGetCount" @reduce="handleGetCount"&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;script&gt; Vue.component('my-component',&#123; template: '\ &lt;div&gt;\ &lt;button @click="Add"&gt;+&lt;/button&gt;\ &lt;button @click="Reduce" :disabled="counter === 1"&gt;-&lt;/button&gt;\ &lt;/div&gt;', data: function()&#123; return &#123; counter: 0 &#125; &#125;, methods:&#123; Add:function()&#123; this.counter++; this.$emit('add',this.counter); &#125;, Reduce:function()&#123; this.counter--; this.$emit('reduce',this.counter); &#125; &#125; &#125;); var app = new Vue(&#123; el: '#app', data: &#123; count: 0 &#125;, methods: &#123; handleGetCount: function(count)&#123; this.count = count; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; vue.js的组件开发中，需要事先进行注册后才可以使用。上述代码中采用的是全局注册，之后采用的形式来使用组件，并且注册的组件是自定义的，使用的是小写加减号的形式。配合template模板来为组件显示内容，并且要显示的内容必须要用一对标签元素包含，否则内容是不会显示的。 代码中使用\是为了被浏览器JS机制识别，当然也用到了v-on指令，在父组件上，给子组件自定义的标签使用了$on()来监听子组件的时间，同时也为组件添加了事件处理函数handleGetCount。不过，代码中更值得一提的是用到了$emit()，是用来触发事件的，改变后的counter就通过它传递给了父组件。在$emit()中第一个参数是自定义事件的名称，第二个参数是要传递的数据，当然也可以省略。 希望今天的文章对正在前端路上奋斗的你有所帮助:)]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式之构造函数模式]]></title>
    <url>%2Fjs-function%2F</url>
    <content type="text"><![CDATA[什么是构造函数模式？ 构造函数模式，又名建造者模式，说到这儿又不得不提到它的概念：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。额~~~，估计这会儿小伙伴们这会儿有点懵圈。如果我告诉小伙伴们，可以不用管这些文字，又能轻松理解并记住构造函数模式呢？很兴奋，有木有？:) 上篇文章中，我曾提到学习编程要树立的一个重要思想，即拟物思想，构造函数依然适用。它是用来创建特定类型的对象，既然是要创建对象，相信有javascript基础的小伙伴已经按耐不住内心的小激动了:)，没错，就是要利用关键字new来创建，当然，这个函数我们可以接收参数，也可以自定义名字，甚至于它的属性和方法。 接下来，类比折纸青蛙(当然也可以折成别的造型)。给一个人张纸，你要求他帮你折出青蛙的造型。而在折的过程，就相当于构造函数的过程，而青蛙，就是这个函数的名字，当然也是我们自定义的。现在，构造函数有了，我们也希望它有自己的属性和方法，用水彩笔为青蛙涂上不同的颜色(纸本身有颜色也可)，并且按着它的最后面，青蛙还可以跳着走，或者吹它，也可以走。这样，就为我们的构造函数增添了属性和方法了。 构造函数模式的作用？ 1、用于创建特定类型的对象。例如上文中提到的折纸青蛙，造型折出来后，只属于你一个人，不是别人，因为你就是那个特定类型的对象。2、首次声明需要为对象赋值。你需要别人拿纸帮你折出青蛙，可以给对方说明你需要什么颜色的青蛙造型，你早告诉对方的过程中其实就是你给对象赋值的过程。3、自定义构造函数，并且声明属性和方法，灵活性较强。折出的青蛙造型，颜色可以是纯色，也可以是五颜六色的，也或者上面有很多小斑点等等都是可以自己要求的。 下面是上面折纸青蛙例子的具体代码，共两步：1、声明构造函数：zheqingwa；2、要给xiaoming这个特定对象折纸青蛙； 温馨提示：注意new关键字的使用。 123456789101112&lt;meta charset = 'utf-8'&gt;&lt;script&gt; function zhiqingwa()&#123; this.color = '纯色'; this.bandian = '无'; this.create = function()&#123; return '颜色:'+ this.color + '斑点:' + this.bandian; &#125; &#125; var xiaoming = new zheqingwa(); console.log(xiaoming.create());&lt;/script&gt; 以上代码仅供小伙伴们参考。 上述例子中是直接使用new关键字来创建对象，那如果没有使用new关键字，那前面声明的构造函数就不能使用了吗？也不尽然。看看下面的代码，你自然会明白。 123456789101112131415&lt;meta charset = 'utf-8'&gt;&lt;script&gt; function zhiqingwa()&#123; if(!(this instanceof zheqingwa))&#123; return new zheqingwa; &#125;; this.color = '纯色'; this.bandian = '无'; this.create = function()&#123; return '颜色:'+ this.color + '斑点:' + this.bandian; &#125; &#125; var xiaoming = zheqingwa(); console.log(xiaoming.create());&lt;/script&gt; 上述代码并没有直接使用new关键字来创建对象，这个时候就要判断构造函数中是否有这个实例对象，如果没有，则再次使用new关键字创建一个这样的对象。注意上例中this的使用。this在构造函数中比较特殊，在使用new关键字创建对象的时候，构造函数内部的this就指向当前创建的那个对象。 好了，以上就是我个人对构造函数模式的理解，希望能帮到好学、爱学的小伙伴们:)]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式之单例模式]]></title>
    <url>%2Fjs-danli%2F</url>
    <content type="text"><![CDATA[javascript中涉及很多设计模式，今天我们要讲的是相对简单也是比较常用的单例模式。而不仅仅对于学习设计模式的小伙伴，还有学习其他编程语言的小伙伴都务必要树立一种思想：拟物思想。通俗来讲，就是要把其中的属性、方法以及其它设计思想通过联系、类比现实生活中的实物的属性和功能，来达到学以致用、触类旁通的目的。 什么是单例模式？ 百度百科给出的解释：单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例，即一个类只有一个对象实例。其实相信很多小伙伴对于这样晦涩难懂的文字感到头大，不过不要紧:)单单从字面意思来讲，单，就是一个的意思；而例则是实例的含义。故我把它总结为四个字：一一对应(或者一实一例)。为什么这样说呢？比如钥匙和锁。一般而言，一把钥匙只对应一把锁，如果钥匙丢了，你需要拿着锁去找锁匠配钥匙；同样的，锁如果丢了，你也会拿着钥匙去找锁匠配锁。(此处小伙伴不要钻牛角尖哦:)) 单例模式实现的方法？ 当然，一般先是要判断实例是否存在，如果存在，则直接返回；如果不存在，则需要先创建，再返回。因为要始终确保一个类只有一个实例对象。 单例模式的作用？ 1、负责模块(注意是同种模块)之间的通信。通信，即类比生活中的实例，就是一种媒介或介质，亦或是桥梁。例如，你要给某人打电话，前提是你要有这个人的手机号，如果这个人没有手机，那么这个人需要先买一个手机。而买手机的过程，其实就是在创建实例的过程；手机和手机号都有了，那要怎样让这个人知道你在给他打电话，当然是来电显示你的手机号或名字，而这个就是一种信号，或者媒介，表示你在给他打电话。2、某一个类的实例对象只存在一个。例如每个人的身份证号是唯一的，即实例的唯一性。3、单例是命名空间的提供者，会让自己的属性和方法私有化，实例对象之间互不干扰，各行其道。 下面是上面打电话例子的具体代码，共四步：1、创建两个独立的实例对象，一个是xiaoming，一个是xiaohong；2、让xiaoming和xiaohong之间进行通信；3、先看一下xiaoming家是否有手机，如果有，则通过手机号13838387438打电话；如果没有手机，则先买手机。4、两个实例对象开始通信。 123456789101112131415161718192021222324&lt;script&gt; var xiaoming = (function()&#123; var xiaomingjia = function(tel)&#123; this.phoneNumber = tel; &#125; var phone; var info = &#123; callPhone: function(tel)&#123; if(!phone)&#123; phone = new xiaomingjia(tel); &#125; return phone; &#125; &#125;; return info; &#125;)(); var xiaohong = &#123; callXiaoming: function(msg)&#123; var _xm = xiaoming.callPhone(msg); alert(_xm.phoneNumber); &#125; &#125; xiaohong.callXiaoming('13838387438');&lt;/script&gt; 好了，以上就是我个人对单例模式的理解，希望能帮到好学、爱学的小伙伴们:)]]></content>
  </entry>
  <entry>
    <title><![CDATA[【实战】Windows系统下利用GitHub+Hexo快速搭建个人博客[下]]]></title>
    <url>%2FgitHub%2F</url>
    <content type="text"><![CDATA[上篇文章相信很多小伙伴已经看过，也已经按照步骤顺利测试成功。接下来这篇文章主要介绍如何把本地Hexo系统发布到GitHub上，闲话少叙，让我们赶快开始码Coding吧:) 本地Hexo系统如何发布到GitHub？ 1、首先，打开Git Bash，在命令窗口输入ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; ，回车即可。 2、接着会提示让你输入密码(是你提交项目的时候进行密码验证时你输入的密码，如果为空，你也可以选择不输入)，并且输入密码的时候是看不见的，之后一路回车下去即可。 温馨提示：以上操作是为了设置本地ssh keys。 3、在本地盘符找到ssh keys，路径一般为 C:\Documents and Settings\Administrator.ssh，在.ssh文件下会有两个文件：id_rsa(私钥)，id_rsa.pub(公钥)，用sublime text(我经常编写代码用的软件，小伙们可自行选择，切忌不要用记事本打开)打开，并复制全部内容。 4、接下来，自行登录github，在账户头像旁边找到setting-&gt;SSH and GPG keys-&gt;New SSH key，之后title随便写，key粘贴刚刚复制的全部内容，之后点击add ssh key，再接着会让你再次输入github密码进行确认，自行输入密码确认即可。如果想要验证是否提交成功，可在命令窗口输入ssh -T git@github.com ，回车即可看到添加成功的提示。 温馨提示：提交成功之后，会收到官方发送的一封邮件。 本地数据如何同步到GitHub上？ 1、首先打开Git Bash，在命令窗口内输入git config --global user.name &quot;你的用户名&quot;，之后回车，不会有任何提示。再次在命令窗口内输入git config --global user.email &quot;你的邮箱&quot;，之后回车，也同样不会有任何提示。 2、接着，安装hexo git插件，在命令窗口输入cnpm install hexo-deployer-git --save，回车即可。 3、打开之前创建的主文件夹，找到_config.yml文件，用sublime text打开，找到url，在后面改成 http://你的用户名.com (这里’你的用户名’指的是注册时的用户名，例如我的用户名是rgbt，所以url就是 http://rgbt.com ，当然冒号后面要有空格哦:)) ，接着在最后找到deploy，type后面是git，repo后面是 https://github.com/你的用户名/你的用户名.github.io.git 例如我的是：https://github.com/rgbt/rgbt.hithub.io.git ，注意这里是https哦:)，branch后面是master，最后记得保存。 温馨提示：type，repo，branch三个冒号后面都要有空格，否则提交会报错。 4、打开Git Bash，在命令窗口输入hexo d -g，回车。如果没有报错，在浏览器中打开网址：你的用户名.github.io，接可以看到你的帅帅的博客喽:)]]></content>
  </entry>
  <entry>
    <title><![CDATA[【实战】Windows系统下利用GitHub+Hexo快速搭建个人博客[上]]]></title>
    <url>%2Fhexo%2F</url>
    <content type="text"><![CDATA[2018已经悄悄来临，一直想要一个自己的博客，之前买了域名和服务器，经过一系列的折腾，终于到了最后工局审核阶段(大概需要15~20天)，而在这段期间，利用GitHub搭建了Hexo博客，用来记录、分享自己在学习前端技术上的知识、心得，在此附上我的GitHub地址: https://rgbt.github.io ,拖了半年多的博客终于上线了，本文是我基于实操经验，即便你没有任何编程基础，或者说是一个技术小白，按照本文的步骤，你也可以快速搭建属于你的博客。 温馨提示：本文教程是基于Windows系统用户，Mac用户可耐心在线等:) 什么是Hexo? 官方解释：Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo官方文档： 英文文档地址：https://hexo.io/docs/index.html中文文档地址：https://hexo.io/zh-cn/docs/index.html 安装软件和注册账号? 1、Node.js 下载地址：https://nodejs.org/en/download/ (选择Windows版本即可)2、GitBash 下载地址：http://gitforwindows.org/3、注册GitHub账号 注册地址：https://github.com/ 准备工作差不多了，是时候开始表演真正的技术啦！:) Node.js安装 Node.js的安装和GitBash的安装基本都是一路next下去(傻瓜式安装)。接着验证软件是否安装成功，可按键盘上的Win+R(或者鼠标“开始菜单”点击“运行”)，在”运行”窗口输入cmd后回车，即可打开命令窗口。接着，在命令窗口内输入node -v 后回车，即可看到安装的node.js版本。此时，在命令窗口再次输入npm -v，来验证npm是否安装。最后输入git --version验证git是否安装成功。 注册GitHub账号 进入GitHub官网，用户名、密码、邮箱进行注册，之后按步骤提示操作，其他默认即可，随后点击continue，之后再点击submit。注册完成之后，官方会给你注册时使用的邮箱发一封激活邮件，按照提示，点击激活即可。 登录账号之后，点击头像旁边的’+’号，选择下面的’New repository’并点击，新创建一个版本库。接着，在Repository name下面填写下yourname.github.io(yourname与你的注册用户名一致，这样yourname.github.io这个就是你博客的域名了)，然后点击下面的绿色按钮，创建这个仓库。到此，你的github设置基本就完成了。 接下来，在你电脑合适的盘符下创建一个新的文件夹(推荐文件夹名字最好使用英文)，用来存放你的博客系统。随后，进入这个文件夹，在空白处右键点击，出现Git Bash Here，选中它，会打开命令行的弹窗口。接着需要npm安装hexo，在此推荐使用国内的淘宝镜像(cnpm)，地址：http://npm.taobao.org/ ，在命令窗口输入npm install -g cnpm --registry=https://registry.npm.taobao.org回车，之后等待安装完毕即可。 再接下来是安装hexo系统，在刚才的命令窗口接着输入cnpm install -g hexo-cli，回车，等待安装完毕。随后再输入cnpm install hexo --save，回车，等待安装，到目前为止，hexo安装算是结束了。验证hexo是否安装成功，命令窗口输入hexo -v，回车。 本地测试Hexo 1、打开Git Bash，在命令窗口输入hexo init，回车，初始化hexo。(第一次初始化可能会失败，如果失败，可多尝试几次) 2、接着输入命令cnpm install，回车，安装生成器。 3、生成器安装完毕后，输入hexo s -g，回车，测试hexo系统。如果出现以下代码Hexo is running at http://localhost:4000/. Press Ctrl + C to stop，表示测试成功。 特别提示：hexo初次本地测试，端口是4000。 4、最后打开浏览器，输入 http://localhost:4000/ ，回车，即可看到hexo测试成功。 特别提示：想要停止运行，在命令窗口按Ctrl + C即可停止。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【小练习】Vue.js计算属性、指令等实现购物车功能]]></title>
    <url>%2Fvue.js%2F</url>
    <content type="text"><![CDATA[简单、小巧、轻量级的Vue.js作为当下较火的MVVM(Model-View-View-Model)新框架之一，更是颠覆了传统前端的开发模式，深受前端开发者的宠爱。而作为前端萌新的我最近也疯狂的迷恋它，这不刚熟悉了指令和计算属性，就迫不及待的做了个小练习：购物车。 Vue.js的核心是视图层(View)，即数据驱动。指令是其中常用的一项功能，有v-if，v-html，v-text，v-show等，主要负责值发生改变的时候，相应的某些行为也会在DOM上发生。例如： 1234567891011&lt;div id='app'&gt; &lt;p v-if='show'&gt;文本是否显示&lt;/p&gt; &lt;script&gt; var app = new Vue(&#123; el:'#app', data:&#123; show:true &#125; &#125;) &lt;/script&gt;&lt;/div&gt; 上述代码中用到的指令是v-if，主要是用作判断，其中创建vue的实例对象后，需要用el挂在元素，data中的代码控制文本的显示隐藏。当show为true时，文本被插入，并显示；否则为false时，则会隐藏。 说到计算属性，不得不提到computed。先来看下面的小例子吧！12345678910111213141516&lt;div id='app'&gt; `&#123;&#123; reversedText &#125;&#125;` &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el:'#app', data:&#123; text:'123,456' &#125;, computed:&#123; reversedText:function()&#123; return this.text.split(',').reverse().join(','); &#125; &#125; &#125;) &lt;/script&gt; 上述代码中，el挂在的元素用了双大括号，文本插入值。其中的reversedText在computed中是一个函数，意思是text这个字符串采用split()方法用逗号分隔，其次用reverse()方法实现倒序，最后用join()方法将分隔的字符串连接。当然，this指向的是vue的实例。 以下是实现购物车的部分代码： index.html：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;购物车&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app" v-cloak&gt; &lt;template v-if="list.length"&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;商品名称&lt;/th&gt; &lt;th&gt;商品单价&lt;/th&gt; &lt;th&gt;商品数量&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for="(item, index) in list"&gt; &lt;td&gt;`&#123;&#123; index + 1 &#125;&#125;`&lt;/td&gt; &lt;td&gt;`&#123;&#123; item.name &#125;&#125;`&lt;/td&gt; &lt;td&gt;`&#123;&#123; item.price &#125;&#125;`&lt;/td&gt; &lt;td&gt; &lt;button @click="handleReduce(index)" :disabled="item.count === 1"&gt;-&lt;/button&gt; `&#123;&#123; item.count &#125;&#125;` &lt;button @click="handleAdd(index)"&gt;+&lt;/button&gt; &lt;/td&gt; &lt;td&gt; &lt;button @click="handleRemove(index)"&gt;删除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tbody&gt; &lt;/table&gt; &lt;div&gt;总价：￥`&#123;&#123; totalPrice &#125;&#125;`&lt;/div&gt; &lt;/template&gt; &lt;div v-else&gt;购物车空空如也&lt;/div&gt; &lt;/div&gt; &lt;script src="https://cdn.bootcss.com/vue/2.5.13/vue.min.js"&gt;&lt;/script&gt; &lt;script src="index.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 其中@click是vue 2.0版本的写法，相当于1.0中的v-on:click。用v-if判断列表的长度是因为当商品的数量减小到1的时候，按钮不能再被点击，即按钮失效，商品数量不小于1。其次，v-for循环出商品的详细信息，包括商品名称、商品数量、以及商品单价，循环时为保证每个商品都被遍历到，采用了in。最后三个点击事件是分别负责商品数量的增减和总价格的计算(并且，当购物车中没有任何商品时，则显示购物车空空如也)。 css.css:1234567891011121314151617181920[v-cloak]&#123; display: none; &#125; table&#123; border: 1px solid #e9e9e9; border-color: collapse; border-spacing: 0; empty-cells: show; //显示表格中空单元格上的边框和背景；如果是hide，隐藏 &#125; th, td&#123; padding: 8px 16px; border: 1px solid #e9e9e9; text-align: center; &#125; th&#123; background: #f7f7f7; color: #5c6b77; font-weight: 600; white-space: nowrap; &#125; index.js:1234567891011121314151617181920212223242526272829303132333435363738394041424344 var app = new Vue(&#123; el:'#app', data:&#123; list:[ &#123; id: 1, name: '某牌香烟', price: 15 &#125;, &#123; id: 2, name: '某牌打火机', price: 888 &#125;, &#123; id: 3, name: '某牌红酒', price: 1982 &#125; ]&#125;, computed:&#123; totalPrice:function()&#123; vat total = 0; for(var i = 0; i &lt; this.list.length i++)&#123; var item = this.list[i]; total += item.price * item.count; &#125; return total.toString().replace(/\B(?=(d&#123;3&#125;)+$)/g,','); &#125; &#125;, methods:&#123; handleReduce:function(index)&#123; if(this.list[index].count === 1) return; this.list[index].count--; &#125;, handleAdd:function(index)&#123; this.list[index].conut++; &#125;, handleRemove:function(index)&#123; this.list.splice(index,1); &#125; &#125; &#125;) 上述代码中的商品数据只是为了测试，所以采用了假数据。值得一提的是computed中计算出的中总价格采用正则了表达式，含义是说总价格采用千分制，简单来说，就是依次匹配，以3个数字为界，后面匹配到的空白处用逗号代替。 此文仅是作为小练习，希望对正在热爱学习vue.js的你有所帮助。当然，该购物车功能完善会在后续的文章中继续，一起期待吧:)]]></content>
  </entry>
  <entry>
    <title><![CDATA[【实战】Bootstrap+Node.js实现物流信息查询小工具[下]]]></title>
    <url>%2Fbootstrap%2F</url>
    <content type="text"><![CDATA[上一篇文章主要介绍了前段页面的搭建方法，相信大家已经有所掌握。接下来该篇文章主要是利用Node.js搭建本地测试环境，调用快递API接口，以获取数据并呈现给前台页面，那现在让我们一起动手实践吧！ 默认小伙伴们的电脑上都已安装好node.js，顺便提一下，测试node.js是否安装可打开命令窗口，输入命令node-v，然后回车即可看到node版本信息。同样的，npm的安装测试命令为npm -v然后回车，同样可以看到npm版本信息。 在合适的盘符下创建项目的主文件夹，同时在该目录下打开命令窗口，项目初始化命令：npm init，之后等待几秒钟，一路回车，此时主文件目录下会出现一个package.json文件，它是项目的配置文件。 接着下载express框架，在命令窗口中输入npm install express回车，等待安装完成即可，此时主文件目录下又会多出两个文件：node_modules和package-lock.json，后者同样也是配置文件。 在文件中创建一个app.js文件，即运行项目时的主文件(当然也可以是别的名字:))，其中代码如下： 1234567891011121314151617var express = require('express'); var request = require('request'); var app = express(); app.get('/query', function(req, res) &#123; res.header('Access-Control-Allow-Origin','*'); res.header('Access-Control-Allow-Methods','PUT,POST,GET,DELETE,OPTIONS'); //接收前台传递的参数 var type = req.query.type; var postid = req.query.postid; request('http://www.kuaidi100.com/query?type='+type+'&amp;postid='+postid+'', function(error, response, body) &#123; res.send(response.body); &#125;);&#125;) app.listen(3000) 首先，在node.js中需要使用哪个模块，就要用require引入，文中需要引入express和request模块。接着利用express函数创建本地服务，request请求的是快递100的API接口，需要传入的参数是用户选择的快递类型和运单号，也就是代码中的type值和postid值，该值在上一文中已有涉及，这里不作过多解释。 请求过程中涉及到node.js中的跨域问题，这个问题将会在新的文章中专门讲述，小伙伴们记得关注哦！ 测试结果截图如下：]]></content>
  </entry>
  <entry>
    <title><![CDATA[【实战】Bootstrap+Node.js实现物流信息查询小工具[上]]]></title>
    <url>%2Fnode.js%2F</url>
    <content type="text"><![CDATA[利用bootstrap进行静态页面搭建，直接CDN引入jQuery，Bootstrap（或本地下载后再引入均可），CDN引入地址分别为：https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js 和 https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.css 、https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.js （未压缩版本）。 部分代码如下： HTML1234567891011121314151617181920212223242526272829303132333435363738&lt;div class="container"&gt; &lt;div class="jumbotron"&gt; &lt;h3&gt;物流查询小工具&lt;/h3&gt; &lt;p&gt;快捷/易用/方便&lt;/p&gt; &lt;div class="col-lg-2"&gt; &lt;div class="form-group"&gt; &lt;select class="form-control" id="select"&gt; &lt;option value="shentong"&gt;申 通&lt;/option&gt; &lt;option value="ems"&gt;EMS&lt;/option&gt; &lt;option value="shunfeng"&gt;顺 丰&lt;/option&gt; &lt;option value="yuantong"&gt;圆 通&lt;/option&gt; &lt;option value="zhongtong"&gt;中 通&lt;/option&gt; &lt;option value="yunda"&gt;韵 达&lt;/option&gt; &lt;option value="tiantian"&gt;天 天&lt;/option&gt; &lt;option value="huitong"&gt;汇 通&lt;/option&gt; &lt;option value="quanfeng"&gt;全 峰&lt;/option&gt; &lt;option value="debang"&gt;德 邦&lt;/option&gt; &lt;option value="zhaijisong"&gt;宅急送&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="col-lg-10"&gt; &lt;div class="input-group"&gt; &lt;input type="text" class="form-control" placeholder="请输入运单号" id="search"&gt; &lt;span class="input-group-btn"&gt; &lt;button class="btn btn-primary" type="button" id="query"&gt;查 询&lt;/button&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="panel panel-info"&gt; &lt;div class="panel-heading"&gt;查询结果：&lt;/div&gt; &lt;div class="panel-body"&gt; &lt;ul class="list-group"&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; CSS:123456789101112131415161718192021222324252627282930313233343536body &#123; text-align: center; &#125; .jumbotron &#123; width: 1000px; height: 600px; background-color: #fff; margin: 10px auto; &#125; .container .panel &#123; margin-top: 80px; &#125; .panel &#123; height: 380px; overflow-y: auto; &#125; ul li&#123; list-style: none; margin: 8px 10px; &#125; ::-webkit-scrollbar&#123; width: 16px; height: 16px; background-color: #fff; width: 5px; &#125; ::-webkit-scrollbar-thumb&#123; border-radius: 10px; -webkit-box-shadow:insert 0 0 6px rgba(0,0,0,.3); background: #f8f8f8; &#125; 特别要说明的是，最后两段代码是针对查询结果右侧的滚动条样式做的兼容处理（当然，如果喜欢别的样式，也可自行修改测试即可）。 JavaScript:1234567891011121314151617181920212223242526272829$(document).ready(function() &#123; $('#query').click(function() &#123; //获取用户选择的快的类型 var type = $('#select').val(); //获取用户输入框的值 var postid = $('#search').val(); //通过ajax调用接口,把返回数据放在页面上 var url = 'http://localhost:3000/query'; var data = &#123; 'type': type, 'postid': postid &#125; $.ajax(&#123; url: url, type: 'get', data: data, success: function(data) &#123; var obj = JSON.parse(data); console.log(obj); for(var i = 0; i &lt; data.length; i++)&#123; $('ul').append('&lt;li&gt;\n'+ '&lt;span&gt;'+obj.data[i].time+'&lt;/span&gt;&lt;br&gt;\n'+ '&lt;span&gt;'+obj.data[i].context+'&lt;/span&gt;\n'+ '&lt;/li&gt;'); &#125; &#125; &#125;); &#125;); &#125;); 调用本地的测试接口：http://localhost:3000/query， 在下一篇文章中会有提到，所以该篇文章不做过多涉及。JSON.parse()方法是将获得的数据整理成JSON数据，以方便观察得到的数据进行分析。在最后尤其要注意，使用append方法添加li到ul里面的时候，因为javascript有自己的运行机制，为防止代码出现报错的情况，需要在末尾添加+号和‘’号来连接。 测试截图如下：]]></content>
  </entry>
  <entry>
    <title><![CDATA[【实操】Git Bash上传本地项目到GitHub]]></title>
    <url>%2FgitBash%2F</url>
    <content type="text"><![CDATA[一入前端深似海，从此妹子是路人。作为前端萌新的我，今天上传了两个项目，在这过程中可谓是一波三折，不过好在最后bling bling~~~上传了，在此附上我的GitHub地址：https://github.com/RGBT/rgbt.github.io， 希望下面我的总结可以帮到入行前端的童鞋。 Step1、输入 ssh-keygen -t rsa -C ‘你注册Github的账号’命令，出现Enter file in which to save the key，不管它，直接回车，出现Overwrite(y/n)，输入y之后一路回车下去，直到密钥生成为止。 Step2、将生成的密钥填入Github的SSH中，名字随便起。 Step3、输入ssh -T git@github.com命令后，回车，验证是否已连接github；若出现Hi 你的账户名! You’ve successfully authenticated, but GitHub does not provide shell access.该字样，说明已经连接成功。 Step4、在你的根目录下，输入git init命令后回车，在目录下会生成.git文件夹（作用是初始化仓库）。 Step5、输入git add README.md后回车（在仓库中没有任何文件的情况下）。 Step6、输入git add .后回车. 表示上传所有文件。 Step7、输入git commit -m “first commit”后回车（表示第一次提交）。 Step8、输入git remote add origin 你的仓库地址，后回车（表示关联远程仓库）。 Step9、输入git pull –rebase origin master命令后回车（更新远程更新到本地）。 Step10、输入git push -u origin master后回车（提交文件到仓库），如果加载到100%，说明上传项目已成功，可进入github仓库，刷新即可看到。]]></content>
  </entry>
</search>
